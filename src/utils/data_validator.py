#!/usr/bin/env python3
"""
Data Validator - Comprehensive data integrity checks for cannabis strain data
Validates both Bronze (raw) and Gold (standardized) layers
"""

import pandas as pd
import numpy as np
import re
from typing import Dict, List, Tuple, Optional, Any

class CannabisDataValidator:
    """
    Comprehensive validator for cannabis strain data
    Ensures data integrity across Bronze and Gold layers
    """
    
    def __init__(self):
        self.validation_results = {
            'total_records': 0,
            'valid_records': 0,
            'invalid_records': 0,
            'warnings': 0,
            'errors': []
        }
        
        # Define validation schemas
        self.bronze_schema = {
            'required_fields': ['strain_name', 'source_url'],
            'optional_fields': [
                'height_raw', 'flowering_time_raw', 'thc_content_raw', 
                'cbd_content_raw', 'yield_raw', 'genetics_raw', 
                'effects_raw', 'flavors_raw', 'description_raw'
            ]
        }\n        \n        self.gold_schema = {\n            'numeric_fields': [\n                'height_cm_min', 'height_cm_max', 'flowering_days_min', 'flowering_days_max',\n                'thc_percentage_min', 'thc_percentage_max', 'cbd_percentage_min', 'cbd_percentage_max',\n                'sativa_percentage', 'indica_percentage', 'yield_grams_per_m2_min', 'yield_grams_per_m2_max',\n                'confidence_score'\n            ],\n            'string_fields': ['effects_standardized', 'flavors_standardized', 'anomaly_notes'],\n            'required_fields': ['confidence_score']\n        }\n    \n    def validate_dataset(self, df: pd.DataFrame, layer_type: str = 'gold') -> Dict:\n        \"\"\"\n        Main validation method for entire dataset\n        \n        Args:\n            df: DataFrame to validate\n            layer_type: 'bronze', 'gold', or 'both'\n            \n        Returns:\n            Comprehensive validation results\n        \"\"\"\n        self.validation_results['total_records'] = len(df)\n        \n        validation_report = {\n            'summary': {},\n            'field_validation': {},\n            'data_quality': {},\n            'recommendations': []\n        }\n        \n        if layer_type in ['bronze', 'both']:\n            bronze_results = self._validate_bronze_layer(df)\n            validation_report['bronze_validation'] = bronze_results\n        \n        if layer_type in ['gold', 'both']:\n            gold_results = self._validate_gold_layer(df)\n            validation_report['gold_validation'] = gold_results\n        \n        # Cross-layer validation if both layers present\n        if layer_type == 'both':\n            cross_results = self._validate_cross_layer_consistency(df)\n            validation_report['cross_layer_validation'] = cross_results\n        \n        # Generate overall summary\n        validation_report['summary'] = self._generate_validation_summary(validation_report)\n        \n        return validation_report\n    \n    def _validate_bronze_layer(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate Bronze layer (raw data) integrity\"\"\"\n        bronze_results = {\n            'schema_validation': {},\n            'content_validation': {},\n            'completeness': {}\n        }\n        \n        # Schema validation\n        bronze_results['schema_validation'] = self._validate_schema(df, self.bronze_schema)\n        \n        # Content validation for Bronze layer\n        bronze_results['content_validation'] = self._validate_bronze_content(df)\n        \n        # Completeness analysis\n        bronze_results['completeness'] = self._analyze_completeness(df, 'bronze')\n        \n        return bronze_results\n    \n    def _validate_gold_layer(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate Gold layer (standardized data) integrity\"\"\"\n        gold_results = {\n            'schema_validation': {},\n            'range_validation': {},\n            'consistency_validation': {},\n            'completeness': {}\n        }\n        \n        # Schema validation\n        gold_results['schema_validation'] = self._validate_schema(df, self.gold_schema)\n        \n        # Range validation (realistic values)\n        gold_results['range_validation'] = self._validate_gold_ranges(df)\n        \n        # Internal consistency validation\n        gold_results['consistency_validation'] = self._validate_gold_consistency(df)\n        \n        # Completeness analysis\n        gold_results['completeness'] = self._analyze_completeness(df, 'gold')\n        \n        return gold_results\n    \n    def _validate_schema(self, df: pd.DataFrame, schema: Dict) -> Dict:\n        \"\"\"Validate DataFrame against schema requirements\"\"\"\n        schema_results = {\n            'missing_required_fields': [],\n            'unexpected_fields': [],\n            'field_type_errors': []\n        }\n        \n        # Check required fields\n        if 'required_fields' in schema:\n            for field in schema['required_fields']:\n                if field not in df.columns:\n                    schema_results['missing_required_fields'].append(field)\n        \n        # Check field types for Gold layer\n        if 'numeric_fields' in schema:\n            for field in schema['numeric_fields']:\n                if field in df.columns:\n                    non_numeric = df[field].apply(\n                        lambda x: not (pd.isna(x) or isinstance(x, (int, float)))\n                    ).sum()\n                    \n                    if non_numeric > 0:\n                        schema_results['field_type_errors'].append({\n                            'field': field,\n                            'expected_type': 'numeric',\n                            'invalid_count': non_numeric\n                        })\n        \n        return schema_results\n    \n    def _validate_bronze_content(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate Bronze layer content quality\"\"\"\n        content_results = {\n            'empty_raw_fields': {},\n            'suspicious_raw_content': [],\n            'source_url_validation': {}\n        }\n        \n        # Check for empty raw fields\n        raw_fields = [col for col in df.columns if col.endswith('_raw')]\n        for field in raw_fields:\n            if field in df.columns:\n                empty_count = df[field].isna().sum() + (df[field] == '').sum()\n                if empty_count > 0:\n                    content_results['empty_raw_fields'][field] = {\n                        'empty_count': empty_count,\n                        'empty_percentage': (empty_count / len(df)) * 100\n                    }\n        \n        # Validate source URLs\n        if 'source_url' in df.columns:\n            url_validation = self._validate_urls(df['source_url'])\n            content_results['source_url_validation'] = url_validation\n        \n        # Check for suspicious content patterns\n        suspicious_patterns = self._detect_suspicious_bronze_content(df)\n        content_results['suspicious_raw_content'] = suspicious_patterns\n        \n        return content_results\n    \n    def _validate_gold_ranges(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate Gold layer numeric ranges\"\"\"\n        range_results = {\n            'out_of_range_values': [],\n            'extreme_values': [],\n            'negative_values': []\n        }\n        \n        # Define realistic ranges\n        field_ranges = {\n            'thc_percentage_min': (0, 45),\n            'thc_percentage_max': (0, 45),\n            'cbd_percentage_min': (0, 30),\n            'cbd_percentage_max': (0, 30),\n            'height_cm_min': (20, 300),\n            'height_cm_max': (20, 300),\n            'flowering_days_min': (30, 120),\n            'flowering_days_max': (30, 120),\n            'sativa_percentage': (0, 100),\n            'indica_percentage': (0, 100),\n            'confidence_score': (1, 5)\n        }\n        \n        for field, (min_val, max_val) in field_ranges.items():\n            if field in df.columns:\n                # Check for out of range values\n                out_of_range = df[\n                    (df[field].notna()) & \n                    ((df[field] < min_val) | (df[field] > max_val))\n                ]\n                \n                if len(out_of_range) > 0:\n                    range_results['out_of_range_values'].append({\n                        'field': field,\n                        'count': len(out_of_range),\n                        'percentage': (len(out_of_range) / len(df)) * 100,\n                        'min_expected': min_val,\n                        'max_expected': max_val,\n                        'actual_min': out_of_range[field].min(),\n                        'actual_max': out_of_range[field].max()\n                    })\n                \n                # Check for negative values where they shouldn't exist\n                if min_val >= 0:\n                    negative_count = (df[field] < 0).sum()\n                    if negative_count > 0:\n                        range_results['negative_values'].append({\n                            'field': field,\n                            'count': negative_count,\n                            'percentage': (negative_count / len(df)) * 100\n                        })\n        \n        return range_results\n    \n    def _validate_gold_consistency(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate internal consistency in Gold layer\"\"\"\n        consistency_results = {\n            'min_max_violations': [],\n            'genetics_sum_errors': [],\n            'confidence_score_issues': []\n        }\n        \n        # Check min/max consistency\n        min_max_pairs = [\n            ('thc_percentage_min', 'thc_percentage_max'),\n            ('cbd_percentage_min', 'cbd_percentage_max'),\n            ('height_cm_min', 'height_cm_max'),\n            ('flowering_days_min', 'flowering_days_max'),\n            ('yield_grams_per_m2_min', 'yield_grams_per_m2_max')\n        ]\n        \n        for min_field, max_field in min_max_pairs:\n            if min_field in df.columns and max_field in df.columns:\n                violations = df[\n                    (df[min_field].notna()) & \n                    (df[max_field].notna()) & \n                    (df[min_field] > df[max_field])\n                ]\n                \n                if len(violations) > 0:\n                    consistency_results['min_max_violations'].append({\n                        'fields': [min_field, max_field],\n                        'violation_count': len(violations),\n                        'percentage': (len(violations) / len(df)) * 100\n                    })\n        \n        # Check genetics percentages sum to 100%\n        if 'sativa_percentage' in df.columns and 'indica_percentage' in df.columns:\n            genetics_errors = df[\n                (df['sativa_percentage'].notna()) & \n                (df['indica_percentage'].notna()) & \n                (abs(df['sativa_percentage'] + df['indica_percentage'] - 100) > 2)  # 2% tolerance\n            ]\n            \n            if len(genetics_errors) > 0:\n                consistency_results['genetics_sum_errors'] = {\n                    'count': len(genetics_errors),\n                    'percentage': (len(genetics_errors) / len(df)) * 100,\n                    'avg_deviation': abs(genetics_errors['sativa_percentage'] + \n                                       genetics_errors['indica_percentage'] - 100).mean()\n                }\n        \n        # Validate confidence scores\n        if 'confidence_score' in df.columns:\n            invalid_confidence = df[\n                (df['confidence_score'].notna()) & \n                ((df['confidence_score'] < 1) | (df['confidence_score'] > 5))\n            ]\n            \n            if len(invalid_confidence) > 0:\n                consistency_results['confidence_score_issues'] = {\n                    'count': len(invalid_confidence),\n                    'percentage': (len(invalid_confidence) / len(df)) * 100\n                }\n        \n        return consistency_results\n    \n    def _validate_cross_layer_consistency(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Validate consistency between Bronze and Gold layers\"\"\"\n        cross_results = {\n            'bronze_gold_mismatches': [],\n            'missing_bronze_for_gold': [],\n            'transformation_quality': {}\n        }\n        \n        # Check if Gold values have corresponding Bronze sources\n        gold_bronze_mappings = [\n            ('thc_percentage_min', 'thc_content_raw'),\n            ('thc_percentage_max', 'thc_content_raw'),\n            ('cbd_percentage_min', 'cbd_content_raw'),\n            ('cbd_percentage_max', 'cbd_content_raw'),\n            ('height_cm_min', 'height_raw'),\n            ('height_cm_max', 'height_raw'),\n            ('flowering_days_min', 'flowering_time_raw'),\n            ('flowering_days_max', 'flowering_time_raw')\n        ]\n        \n        for gold_field, bronze_field in gold_bronze_mappings:\n            if gold_field in df.columns and bronze_field in df.columns:\n                # Find records with Gold data but no Bronze source\n                missing_bronze = df[\n                    (df[gold_field].notna()) & \n                    (df[bronze_field].isna() | (df[bronze_field] == ''))\n                ]\n                \n                if len(missing_bronze) > 0:\n                    cross_results['missing_bronze_for_gold'].append({\n                        'gold_field': gold_field,\n                        'bronze_field': bronze_field,\n                        'count': len(missing_bronze),\n                        'percentage': (len(missing_bronze) / len(df)) * 100\n                    })\n        \n        return cross_results\n    \n    def _analyze_completeness(self, df: pd.DataFrame, layer_type: str) -> Dict:\n        \"\"\"Analyze data completeness for the specified layer\"\"\"\n        completeness_results = {\n            'overall_completeness': 0,\n            'field_completeness': {},\n            'completeness_distribution': {}\n        }\n        \n        if layer_type == 'bronze':\n            target_fields = [col for col in df.columns if col.endswith('_raw')] + ['strain_name', 'source_url']\n        else:  # gold\n            target_fields = self.gold_schema['numeric_fields'] + self.gold_schema['string_fields']\n        \n        # Calculate field-level completeness\n        total_completeness = 0\n        valid_fields = 0\n        \n        for field in target_fields:\n            if field in df.columns:\n                non_null_count = df[field].notna().sum()\n                non_empty_count = (df[field] != '').sum() if df[field].dtype == 'object' else non_null_count\n                \n                completeness_pct = (non_empty_count / len(df)) * 100\n                completeness_results['field_completeness'][field] = completeness_pct\n                \n                total_completeness += completeness_pct\n                valid_fields += 1\n        \n        if valid_fields > 0:\n            completeness_results['overall_completeness'] = total_completeness / valid_fields\n        \n        # Analyze completeness distribution\n        completeness_ranges = {\n            'excellent': (90, 100),\n            'good': (70, 90),\n            'fair': (50, 70),\n            'poor': (0, 50)\n        }\n        \n        for range_name, (min_pct, max_pct) in completeness_ranges.items():\n            count = sum(\n                1 for pct in completeness_results['field_completeness'].values()\n                if min_pct <= pct < max_pct\n            )\n            completeness_results['completeness_distribution'][range_name] = count\n        \n        return completeness_results\n    \n    def _validate_urls(self, url_series: pd.Series) -> Dict:\n        \"\"\"Validate URL format and accessibility\"\"\"\n        url_results = {\n            'total_urls': len(url_series),\n            'valid_format': 0,\n            'invalid_format': 0,\n            'empty_urls': 0\n        }\n        \n        # URL pattern for basic validation\n        url_pattern = re.compile(\n            r'^https?://'  # http:// or https://\n            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+'  # domain...\n            r'(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # host...\n            r'localhost|'  # localhost...\n            r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n            r'(?::\\d+)?'  # optional port\n            r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n        \n        for url in url_series:\n            if pd.isna(url) or url == '':\n                url_results['empty_urls'] += 1\n            elif url_pattern.match(str(url)):\n                url_results['valid_format'] += 1\n            else:\n                url_results['invalid_format'] += 1\n        \n        return url_results\n    \n    def _detect_suspicious_bronze_content(self, df: pd.DataFrame) -> List[Dict]:\n        \"\"\"Detect suspicious patterns in Bronze layer content\"\"\"\n        suspicious_patterns = []\n        \n        # Check for overly repetitive content\n        raw_fields = [col for col in df.columns if col.endswith('_raw')]\n        \n        for field in raw_fields:\n            if field in df.columns:\n                # Check for exact duplicates\n                value_counts = df[field].value_counts()\n                if len(value_counts) > 0:\n                    most_common_count = value_counts.iloc[0]\n                    total_non_null = df[field].notna().sum()\n                    \n                    if total_non_null > 0 and (most_common_count / total_non_null) > 0.5:\n                        suspicious_patterns.append({\n                            'field': field,\n                            'pattern_type': 'high_duplication',\n                            'most_common_value': value_counts.index[0],\n                            'occurrence_count': most_common_count,\n                            'percentage': (most_common_count / total_non_null) * 100\n                        })\n        \n        return suspicious_patterns\n    \n    def _generate_validation_summary(self, validation_report: Dict) -> Dict:\n        \"\"\"Generate overall validation summary\"\"\"\n        summary = {\n            'total_records': self.validation_results['total_records'],\n            'validation_status': 'PASSED',\n            'critical_issues': 0,\n            'warnings': 0,\n            'data_quality_score': 100\n        }\n        \n        # Count critical issues and warnings\n        critical_issues = 0\n        warnings = 0\n        \n        # Check Bronze layer issues\n        if 'bronze_validation' in validation_report:\n            bronze = validation_report['bronze_validation']\n            if bronze['schema_validation']['missing_required_fields']:\n                critical_issues += len(bronze['schema_validation']['missing_required_fields'])\n        \n        # Check Gold layer issues\n        if 'gold_validation' in validation_report:\n            gold = validation_report['gold_validation']\n            if gold['range_validation']['out_of_range_values']:\n                critical_issues += sum(item['count'] for item in gold['range_validation']['out_of_range_values'])\n            if gold['consistency_validation']['min_max_violations']:\n                critical_issues += sum(item['violation_count'] for item in gold['consistency_validation']['min_max_violations'])\n        \n        summary['critical_issues'] = critical_issues\n        summary['warnings'] = warnings\n        \n        # Determine overall status\n        if critical_issues > 0:\n            summary['validation_status'] = 'FAILED'\n            summary['data_quality_score'] = max(0, 100 - (critical_issues / self.validation_results['total_records'] * 100))\n        elif warnings > 0:\n            summary['validation_status'] = 'PASSED_WITH_WARNINGS'\n            summary['data_quality_score'] = max(80, 100 - (warnings / self.validation_results['total_records'] * 10))\n        \n        return summary\n\ndef main():\n    \"\"\"Example usage of the Cannabis Data Validator\"\"\"\n    \n    # Create sample data for testing\n    sample_data = {\n        'strain_name': ['Blue Dream', 'Invalid Strain', 'Good Strain'],\n        'source_url': ['https://example.com/blue-dream', 'invalid-url', 'https://example.com/good'],\n        'thc_content_raw': ['18-24% THC', '60% THC', '15-20% THC'],  # 60% is impossible\n        'height_raw': ['120-180cm', '500cm tall', '80-120cm'],  # 500cm is impossible\n        'thc_percentage_min': [18, 60, 15],  # 60% is out of range\n        'thc_percentage_max': [24, 60, 20],\n        'height_cm_min': [120, 500, 80],  # 500cm is out of range\n        'height_cm_max': [180, 500, 120],\n        'confidence_score': [4, 2, 5]\n    }\n    \n    df = pd.DataFrame(sample_data)\n    \n    validator = CannabisDataValidator()\n    validation_results = validator.validate_dataset(df, layer_type='both')\n    \n    print(\"=== CANNABIS DATA VALIDATION REPORT ===\")\n    print(f\"Total Records: {validation_results['summary']['total_records']}\")\n    print(f\"Validation Status: {validation_results['summary']['validation_status']}\")\n    print(f\"Critical Issues: {validation_results['summary']['critical_issues']}\")\n    print(f\"Data Quality Score: {validation_results['summary']['data_quality_score']:.1f}/100\")\n    \n    # Show some specific validation results\n    if 'gold_validation' in validation_results:\n        gold_val = validation_results['gold_validation']\n        if gold_val['range_validation']['out_of_range_values']:\n            print(\"\\nOut of Range Values Found:\")\n            for item in gold_val['range_validation']['out_of_range_values']:\n                print(f\"  - {item['field']}: {item['count']} records ({item['percentage']:.1f}%)\")\n\nif __name__ == \"__main__\":\n    main()